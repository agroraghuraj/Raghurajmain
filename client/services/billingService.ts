import apiClient from "@/lib/api";
import productService from "@/services/productService";

// GST Configuration for state detection
const gstConfig = {
  DELHI: {
    names: ["delhi", "new delhi"],
    codes: ["110", "11"],
    gst: 18, // Can be overridden by company settings
  },
  MUMBAI: {
    names: ["mumbai", "maharashtra"],
    codes: ["400", "401", "402", "403"],
    gst: 18, // Can be overridden by company settings
  },
  BANGALORE: {
    names: ["bangalore", "bengaluru", "karnataka"],
    codes: ["560"],
    gst: 18, // Can be overridden by company settings
  },
  OTHER: {
    names: [],
    codes: [],
    gst: 18, // Can be overridden by company settings
  },
};

// Standard Indian GST rates
export const GST_RATES = {
  0: "0% - Exempt",
  5: "5% - Essential items", 
  12: "12% - Standard rate",
  18: "18% - Standard rate",
  28: "28% - Luxury items"
};

// Calculate Bill function as provided
function calculateBill(data: any) {
  try {
    // Validate required data
    if (!data || !data.items || !Array.isArray(data.items)) {
      throw new Error("Invalid bill data: items array is required");
    }

    // 1‚É£ Subtotal
    let subtotal = data.items.reduce(
      (acc: number, item: any) => {
        if (!item || typeof item.itemPrice !== 'number' || typeof item.itemQuantity !== 'number') {
          return acc;
        }
        const itemTotal = item.itemPrice * item.itemQuantity;
        return acc + itemTotal;
      },
      0,
    );

    // 2Ô∏è‚É£ Discount
    let discountAmount = (subtotal * (data.discount || 0)) / 100;
    let afterDiscount = subtotal - discountAmount;

    // 3Ô∏è‚É£ Detect state from customerState field or address / pincode
    let stateKey = "OTHER";

    // First, try to use the customerState field if provided
    if (data.customerState && typeof data.customerState === 'string') {
      const customerState = data.customerState.toLowerCase();
      for (let key in gstConfig) {
        const cfg = gstConfig[key];
        if (cfg.names && Array.isArray(cfg.names) && 
            cfg.names.some((name) => customerState.includes(name.toLowerCase()))) {
          stateKey = key;
          break;
        }
      }
    } else {
      // Fallback to address-based detection
      for (let key in gstConfig) {
        const cfg = gstConfig[key];

        // Match by state name in address
        if (
          data.customerAddress &&
          typeof data.customerAddress === 'string' &&
          cfg.names &&
          Array.isArray(cfg.names) &&
          cfg.names.some((name) => {
            return data.customerAddress.toLowerCase().includes(name.toLowerCase());
          })
        ) {
          stateKey = key;
          break;
        }
      }
    }

    // 4Ô∏è‚É£ GST % - Use proper GST rate based on product or company settings
    // For now, use 18% as default, but this should be determined by product GST rate
    let gstPercent = gstConfig[stateKey].gst;
    
    // If items have individual GST rates, use the first item's rate
    if (data.items && data.items.length > 0 && data.items[0].gstRate) {
      gstPercent = data.items[0].gstRate;
    }
    
    let gstAmount = (afterDiscount * gstPercent) / 100;

    // 5Ô∏è‚É£ Final Total
    let totalAmount = afterDiscount + gstAmount;

    // 6Ô∏è‚É£ Payment logic
    let remainingAmount = 0;
    if (data.paymentType === "Partial") {
      remainingAmount = totalAmount - (data.paidAmount || 0);
    }

    const result = {
      subtotal,
      discountAmount,
      afterDiscount,
      gstPercent,
      gstAmount,
      totalAmount,
      paidAmount: data.paidAmount || 0,
      remainingAmount,
      stateKey,
    };
    
    return result;
  } catch (error) {
    // Return default values in case of error
    return {
      subtotal: 0,
      discountAmount: 0,
      afterDiscount: 0,
      gstPercent: 18, // Default to 18% if no specific rate is found
      gstAmount: 0,
      totalAmount: 0,
      paidAmount: data?.paidAmount || 0,
      remainingAmount: 0,
      stateKey: "OTHER",
    };
  }
}

// Bill Service Interface
export interface BillItem {
  itemName: string;
  itemPrice: number;
  itemQuantity: number;
  itemTotal?: number;
}

export interface BillData {
  customerName: string;
  customerPhone: string;
  customerId?: string; // Add customerId field
  customerAddress?: string;
  billNumber?: string; // Make optional - will be auto-generated by backend
  pincode?: string;
  items: BillItem[];
  discount?: number;
  paymentType: "Full" | "Partial";
  paidAmount?: number;
  remainingAmount?: number; // Add remainingAmount field
  paymentMethod: "cash" | "online" | "mixed";
  observation?: string;
  termsAndConditions?: string;
  billType: "GST" | "NON_GST" | "QUOTATION" | "Demo";
  status?: string; // Add status field
}

export interface Bill extends BillData {
  id: string;
  billNumber: string;
  billDate: string;
  customerId?: string; // Add customerId field
  subtotal: number;
  discountAmount: number;
  afterDiscount: number;
  gstPercent: number;
  gstAmount: number;
  totalAmount: number;
  remainingAmount: number;
  stateKey: string;
  status?: string; // Add status field for drafts
  createdAt: string;
  updatedAt?: string;
}

// Billing Service using axios
export const billingService = {
  // Create new bill
  async createBill(billData: BillData): Promise<Bill> {
    try {
      // Validate bill data
      if (!billData || !billData.items || !Array.isArray(billData.items) || billData.items.length === 0) {
        throw new Error("Invalid bill data: items array is required and cannot be empty");
      }
      
      // Validate required fields
      if (!billData.customerName || !billData.customerPhone) {
        throw new Error("Invalid bill data: customerName and customerPhone are required");
      }
      
      // Ensure customerAddress is a string
      if (billData.customerAddress && typeof billData.customerAddress !== 'string') {
        billData.customerAddress = String(billData.customerAddress);
      }
      
      // Ensure pincode is a string
      if (billData.pincode && typeof billData.pincode !== 'string') {
        billData.pincode = String(billData.pincode);
      }
      
      // Ensure billType is valid and convert input values to proper enum values
      if (billData.billType) {
        const billTypeLower = (billData.billType as string).toLowerCase();
        if (billTypeLower === "non-gst" || billTypeLower === "non_gst") {
          billData.billType = "NON_GST";
        } else if (billTypeLower === "gst") {
          billData.billType = "GST";
        } else if (billTypeLower === "quotation") {
          billData.billType = "QUOTATION";
        } else if (billTypeLower === "demo") {
          billData.billType = "Demo";
        }
      }
      
      // Calculate bill totals using the provided function
      const calculations = calculateBill(billData);

      // Reduce stock quantities for each item in the bill
      if (billData.items && billData.items.length > 0) {
        console.log('üì¶ Reducing stock for bill items:', billData.items);
        
        for (const item of billData.items) {
          if (item.itemName && item.itemQuantity) {
            try {
              // Get all products to find the matching one by name
              const { products } = await productService.getAllProducts();
              
              // Find the product by name
              const product = products.find((p: any) => 
                p.name === item.itemName || p.name.toLowerCase() === item.itemName.toLowerCase()
              );
              
              if (product && product.stockQuantity !== undefined) {
                const newStockQuantity = Math.max(0, product.stockQuantity - item.itemQuantity);
                
                // Update product stock using the product service
                await productService.updateProduct(product.id, {
                  stockQuantity: newStockQuantity
                });
                
                console.log(`üìâ Reduced stock for ${item.itemName}: ${product.stockQuantity} ‚Üí ${newStockQuantity}`);
              } else {
                console.warn(`‚ö†Ô∏è Product not found for ${item.itemName}`);
              }
            } catch (error) {
              console.error(`‚ùå Failed to reduce stock for product ${item.itemName}:`, error);
              // Continue with other products even if one fails
            }
          }
        }
      }

      // Ensure all required fields are properly set
      const billPayload = {
        ...billData,
        ...calculations,
        billDate: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        // Ensure pincode is a string, not undefined
        pincode: billData.pincode || "",
        // Ensure customerAddress is a string, not undefined
        customerAddress: billData.customerAddress || "",
        // Ensure all item fields are properly set
        items: billData.items.map(item => ({
          ...item,
          itemName: item.itemName || "",
          itemPrice: Number(item.itemPrice) || 0,
          itemQuantity: Number(item.itemQuantity) || 0,
          itemTotal: Number(item.itemTotal) || 0,
        })),
      };

      // Try new endpoint first, then fallback to old endpoint
      let response;
      try {
        response = await apiClient.post("/api/newBill/register", billPayload);
      } catch (newEndpointError) {
        response = await apiClient.post("/api/newbill/register", billPayload);
      }

      let bill;
      // Handle different response formats
      if (response.data && response.data.bill) {
        bill = response.data.bill;
      } else if (response.data && response.data.data) {
        bill = response.data.data;
      } else {
        bill = response.data;
      }

      // Normalize the _id field to id
      const normalizedBill = {
        ...bill,
        id: bill.id || bill._id,
      };
      
      return normalizedBill;
    } catch (error) {
      throw error;
    }
  },
  
  // Get all bills
  async getAllBills(): Promise<Bill[]> {
    try {
      // Try new endpoint first, then fallback to old endpoint
      let response;
      try {
        response = await apiClient.get("/api/newBill/getBills");
      } catch (newEndpointError) {
        response = await apiClient.get("/getBills");
      }

      let bills = [];
      // Handle different response formats
      if (response.data && Array.isArray(response.data.data)) {
        bills = response.data.data;
      } else if (Array.isArray(response.data)) {
        bills = response.data;
      } else if (response.data && response.data.success && response.data.bills) {
        bills = response.data.bills;
      }

      // Normalize all bills to have 'id' field for consistent client usage
      const normalizedBills = bills.map((bill) => ({
        ...bill,
        id: bill.id || bill._id,
      }));

      // Remove duplicates based on ID only (not bill number, as multiple bills can have same number)
      const uniqueBills = normalizedBills.filter((bill, index, self) => {
        const isUnique = index === self.findIndex(b => 
          (b.id && bill.id && b.id === bill.id) || 
          (b._id && bill._id && b._id === bill._id)
        );
        return isUnique;
      });

      return uniqueBills;
    } catch (error) {
      console.error('‚ùå getAllBills error:', error);
      return [];
    }
  },

  // Get bill by ID
  async getBillById(id: string): Promise<Bill> {
    try {
      // Try new endpoint first, then fallback to old endpoint
      let response;
      try {
        response = await apiClient.get(`/api/newBill/getBillsById/${id}`);
      } catch (newEndpointError) {
        response = await apiClient.get(`/getBillsbyid/${id}`);
      }

      let bill;
      // Handle different response formats
      if (response.data && response.data.data) {
        bill = response.data.data;
      } else if (response.data && response.data.bill) {
        bill = response.data.bill;
      } else {
        bill = response.data;
      }

      // Normalize the _id field to id
      return {
        ...bill,
        id: bill.id || bill._id || id,
      };
    } catch (error) {
      console.error('Error fetching bill by ID:', error);
      throw error;
    }
  },

  // Update bill
  async updateBill(id: string, billData: Partial<BillData>): Promise<Bill> {
    try {
      console.log('üîÑ Updating bill with ID:', id);
      console.log('üìù Bill data to update:', billData);
      
      // Recalculate if items or discount changed
      const calculations = billData.items
        ? calculateBill(billData as BillData)
        : {};

      // Reduce stock quantities for each item in the updated bill
      if (billData.items && billData.items.length > 0) {
        console.log('üì¶ Reducing stock for updated bill items:', billData.items);
        
        for (const item of billData.items) {
          if (item.itemName && item.itemQuantity) {
            try {
              // Get all products to find the matching one by name
              const { products } = await productService.getAllProducts();
              
              // Find the product by name
              const product = products.find((p: any) => 
                p.name === item.itemName || p.name.toLowerCase() === item.itemName.toLowerCase()
              );
              
              if (product && product.stockQuantity !== undefined) {
                const newStockQuantity = Math.max(0, product.stockQuantity - item.itemQuantity);
                
                // Update product stock using the product service
                await productService.updateProduct(product.id, {
                  stockQuantity: newStockQuantity
                });
                
                console.log(`üìâ Reduced stock for ${item.itemName}: ${product.stockQuantity} ‚Üí ${newStockQuantity}`);
              } else {
                console.warn(`‚ö†Ô∏è Product not found for ${item.itemName}`);
              }
            } catch (error) {
              console.error(`‚ùå Failed to reduce stock for product ${item.itemName}:`, error);
              // Continue with other products even if one fails
            }
          }
        }
      }

      const billPayload = {
        ...billData,
        ...calculations,
        updatedAt: new Date().toISOString(),
      };

      console.log('üì¶ Final payload:', billPayload);
      console.log('üïí UpdatedAt timestamp:', billPayload.updatedAt);
      console.log('üåê API endpoint:', `/api/newBill/updateBills/${id}`);

      // Use the correct backend endpoint
      const response = await apiClient.put(
        `/api/newBill/updateBills/${id}`,
        billPayload,
      );

      // Handle server response - the server returns the bill in response.data.bill
      let updatedBill;
      let changes = [];
      
      if (response.data && response.data.bill) {
        updatedBill = response.data.bill;
        changes = response.data.changes || [];
      } else if (response.data && response.data.data) {
        updatedBill = response.data.data;
        changes = response.data.changes || [];
      } else {
        updatedBill = response.data;
        changes = response.data.changes || [];
      }

      console.log('‚úÖ Bill update response received');
      console.log('üïí UpdatedAt from server:', updatedBill.updatedAt);
      console.log('üìÖ CreatedAt from server:', updatedBill.createdAt);
      console.log('üìù Changes detected:', changes);

      // Normalize the _id field to id for consistent client-side usage
      const normalizedBill = {
        ...updatedBill,
        id: updatedBill.id || updatedBill._id || id,
        _changes: changes, // Store changes for frontend use
      };

      return normalizedBill;
  } catch (error) {
    console.error('‚ùå Error updating bill:', error);
    console.error('‚ùå Error response:', error.response?.data);
    console.error('‚ùå Error status:', error.response?.status);
    console.error('‚ùå Error endpoint:', error.config?.url);
    throw error;
  }
  },

  // Delete bill
  async deleteBill(id: string): Promise<void> {
    // Try multiple possible endpoints for delete
    const deleteEndpoints = [
      `/api/newBill/deleteBills/${id}`,
    ];

    for (const endpoint of deleteEndpoints) {
      try {
        await apiClient.delete(endpoint);
        return;
      } catch (error: any) {
        if (error.response?.status === 404) {
          continue;
        }
        // If it's not a 404, throw the error
        throw error;
      }
    }

    // If all endpoints fail, throw a helpful error
    throw new Error(
      "Delete bill functionality is not available on the server. The server needs to implement a delete endpoint like /api/newBill/delete/:id",
    );
  },

  // Calculate bill totals (utility function)
  calculateBill,

  // Generate bill number
  generateBillNumber(billType: string = "GST"): string {
    const timestamp = Date.now();
    const prefix =
      billType === "GST" ? "GST" : billType === "NON_GST" ? "NGST" : "QUO";
    return `${prefix}/24/${timestamp.toString().slice(-6)}`;
  },

  // Get bills by customer ID
  async getBillsByCustomer(customerId: string): Promise<Bill[]> {
    try {
      // First try the dedicated customer endpoint
      try {
        const response = await apiClient.get(`/api/newBill/customer/${customerId}`);
        
        let bills = [];
        if (response.data && Array.isArray(response.data.data)) {
          bills = response.data.data;
        } else if (Array.isArray(response.data)) {
          bills = response.data;
        } else if (response.data && response.data.success && response.data.bills) {
          bills = response.data.bills;
        }

        return bills.map((bill) => ({
          ...bill,
          id: bill.id || bill._id,
        }));
      } catch (customerEndpointError) {
        // Fallback: Get all bills and filter by customer
        const allBills = await this.getAllBills();
        
        // Filter bills by customer ID, phone, or name
        const customerBills = allBills.filter(bill => {
          const matchesId = bill.customerId === customerId;
          const matchesPhone = bill.customerPhone === customerId;
          const matchesName = bill.customerName?.toLowerCase().includes(customerId.toLowerCase());
          
          return matchesId || matchesPhone || matchesName;
        });
        
        return customerBills;
      }
    } catch (error) {
      return [];
    }
  },

  // Get recent bills
  async getRecentBills(limit: number = 5): Promise<Bill[]> {
    try {
      // First try the dedicated recent bills endpoint
      try {
        const response = await apiClient.get(`/api/newBill/recent?limit=${limit}`);
        
        let bills = [];
        if (response.data && Array.isArray(response.data.data)) {
          bills = response.data.data;
        } else if (Array.isArray(response.data)) {
          bills = response.data;
        } else if (response.data && response.data.success && response.data.bills) {
          bills = response.data.bills;
        }

        return bills.map((bill) => ({
          ...bill,
          id: bill.id || bill._id,
        }));
      } catch (recentEndpointError) {
        // Fallback: Get all bills and sort by date
        const allBills = await this.getAllBills();
        
        // Sort by creation date (most recent first) and limit
        const recentBills = allBills
          .sort((a, b) => new Date(b.updatedAt || b.createdAt || b.billDate).getTime() - new Date(a.updatedAt || a.createdAt || a.billDate).getTime())
          .slice(0, limit);
        
        return recentBills;
      }
    } catch (error) {
      return [];
    }
  },
};

export default billingService;